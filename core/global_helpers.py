from typing import Literal, Unionfrom global_data.global_context import Contextfrom global_data.metric import MetricData, Logimport os, timeimport sysdef clear_console():    time.sleep(0.1)    os.system('cls' if os.name == 'nt' else 'clear')    Log.add(message="console has been cleared",level="DEBUG")def user_input_record(mode: Literal["str", "int", "float"], message: str) -> Union[str, int, float, None]:    Log.add(message=f"user input record start in MODE {mode}", level="DEBUG")    raw_input_val = input(message)    result = None    if mode == "str":        result = raw_input_val    elif mode == "int":        try:            result = int(raw_input_val)        except ValueError:            try:                float_value = float(raw_input_val)                rounded_value = int(float_value)                result = rounded_value                Log.add(message=f"Your number {float_value} was rounded to {rounded_value}", level="INFO")                Log.add(message=f"Number {float_value} was rounded to {rounded_value}", level="DEBUG")            except ValueError:                Log.add(message=f"Invalid input: {raw_input_val}", level="INFO")                Log.add(message=f"Invalid input: {raw_input_val} requires Int", level="ERROR")    elif mode == "float":        try:            result = float(raw_input_val)        except ValueError:            Log.add(message=f"Invalid input: {raw_input_val}", level="INFO")            Log.add(message=f"Invalid input: {raw_input_val} requires Float", level="ERROR")    Log.add(message=f"user input record has finished with result: {result}", level="DEBUG")    return resultdef user_input_on_press() -> str or None:    Log.add(message="user input on press has started", level="DEBUG")    Context.vector = [0, 0]    def get_single_keypress():        if os.name == 'nt':            import msvcrt            first = msvcrt.getch()            # Extended/special keys (e.g., arrows, F1â€“F12)            if first in {b'\x00', b'\xe0'}:                second = msvcrt.getch()                key_map = {                        b'H': "up",                        b'P': "down",                        b'K': "left",                        b'M': "right",                }                return key_map.get(second, "unknown")            else:                try:                    return first.decode().lower()                except UnicodeDecodeError:                    Log.add(message="UnicodeDecodeError", level="ERROR")                    return "unknown"        else:            import tty            import termios            fd = sys.stdin.fileno()            old_settings = termios.tcgetattr(fd)            try:                tty.setraw(fd)                key = sys.stdin.read(1)                if key == '\x1b':  # possible escape sequence                    seq = sys.stdin.read(2)                    arrows = {"[A": "up", "[B": "down", "[C": "right", "[D": "left"}                    return arrows.get(seq, "unknown")                return key.lower()            finally:                termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)    key = get_single_keypress()    key_map = {        "esc": "esc",        "\x1b": "esc",        "\r": "enter",        "\n": "enter",        "\x7f": "backspace",        "\b": "backspace",        " ": "space",        "\x20": "space",        "w": "w",        "a": "a",        "s": "s",        "d": "d",    }    key = key_map.get(key, key)    MetricData.append_metric_data("Last key pressed", key)    Context.metric_data = {"Latest key pressed": key}    Log.add(message=f"user input finished with {key} result", level="DEBUG")    if key in ("w", "up"):        Context.vector = [0, -1]        return Context.vector    elif key in ("s", "down"):        Context.vector = [0, 1]        return Context.vector    elif key in ("a", "left"):        Context.vector = [-1, 0]        return Context.vector    elif key in ("d", "right"):        Context.vector = [1, 0]        return Context.vector    elif key == "enter":        return "enter"    elif key == "esc":        return "esc"    elif key == "backspace":        return "backspace"    elif key == "space":        return "space"    else:        Log.add(message=f"Unrecognized key: {key}", level="ERROR")        return None    def back():    if len(Context.last_menu_position_stack) > 1:        Context.last_menu_position_stack.pop(-1)        Context.menu_position = Context.last_menu_position_stack[-1]        Context.all_menu_functions[Context.menu_position]()    else:        Context.menu_position = "main_menu"        Context.all_menu_functions["main_menu"]()        Log.add(message=f"handled error empty Context.last_menu_position_stack", level="ERROR")                def push_menu_position(current:str):    if not Context.last_menu_position_stack or Context.last_menu_position_stack[-1] != current:        Context.last_menu_position_stack.append(current)        Log.add(message=f"{current} has been pushed to Context.last_menu_position_stack", level="DEBUG")                def difficulty_setter(difficulty_def : str):    from mines_game.menu import difficulty    if difficulty_def == "easy":        Context.difficulty = "easy"        Context.difficulty_modifier = 0.20    elif difficulty_def == "medium":        Context.difficulty = "medium"        Context.difficulty_modifier = 0.35    elif difficulty_def == "hard":        Context.difficulty = "hard"        Context.difficulty_modifier = 0.45    Log.add(message=f"difficulty has been changed to {Context.difficulty}", level="INFO")    difficulty()def grid_setter(chosed: str):    from mines_game.menu import grid_settings    if chosed == "10x10":        Context.grid_width = 10        Context.grid_height = 10    elif chosed == "20x20":        Context.grid_width = 20        Context.grid_height = 20    elif chosed == "30x30":        Context.grid_width = 30        Context.grid_height = 30    elif chosed == "custom":        inserted_number = user_input_record("int","your custom width: ")        Context.grid_width = inserted_number        inserted_number = user_input_record("int", "your custom height: ")        Context.grid_height = inserted_number    Log.add(message=f"Grid has been set to {Context.grid_width}x{Context.grid_height}", level="INFO")    grid_settings()def log_visual_setter(log_to_show: str):    from mines_game.menu import log_settings    attr_map = {        "info": "log_info_state",        "debug": "log_debug_state",        "error": "log_error_state",        "metric": "metric_state"    }    attr = attr_map.get(log_to_show.lower())    if attr is None:        Log.add(f"Invalid log type: {log_to_show}", level="ERROR")        return    current_value = getattr(Context, attr)    setattr(Context, attr, not current_value)    Log.add(        message=f"{log_to_show.capitalize()} log has been: {'enabled' if not current_value else 'disabled'}",        level="INFO"    )    log_settings()def cheat_grid():    from mines_game.menu import settings    attr = "cheat_grid"    current_value = getattr(Context, attr)    setattr(Context, attr, not current_value)    Log.add(        message=f"Cheat mode has been: {'enabled' if not current_value else 'disabled'}",        level="INFO"    )    settings()            