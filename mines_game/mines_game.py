import randomfrom abc import ABC, abstractmethodfrom collections import dequefrom global_data.global_context import Contextfrom global_data.metric import Logclass Tile(ABC):    def __init__(self, x: int, y: int):        self.x = x        self.y = y    @abstractmethod    def scan_context(self, tile_grid):        pass    @abstractmethod    def on_click(self, tile_grid)->bool:        return Trueclass EmptyTile(Tile):    def __init__(self, x, y):        super().__init__(x, y)        self.adjacent_mines = 0        self.revealed = False        self.is_mine = False        self.is_flagged = False        self.position = (x,y)        Context.empty_tiles.add(self.position)    def scan_context(self, tile_grid):        neighbors = tile_grid.get_neighbors(self.x, self.y)        self.adjacent_mines = sum(isinstance(tile, MineTile) for tile in neighbors)    def on_click(self, tile_grid)->bool:        if self.revealed or self.is_flagged:            return False        Log.add(message=f"Empty tile ({self.x}, {self.y}) has been revealed", level="DEBUG")        self.revealed = True        to_reveal = deque([(self.x, self.y)])        visited = set()        while to_reveal:            x, y = to_reveal.popleft()            Context.empty_tiles.discard((x, y))            if (x, y) in visited:                continue            visited.add((x, y))            tile = tile_grid.grid[y][x]            if not tile.revealed:                tile.revealed = True            if tile.adjacent_mines == 0:                for neighbor in tile_grid.get_neighbors(x, y):                    if isinstance(neighbor, EmptyTile) and not neighbor.revealed and (neighbor.x, neighbor.y) not in visited:                        to_reveal.append((neighbor.x, neighbor.y))        return Falseclass MineTile(Tile):    def __init__(self, x, y):        super().__init__(x, y)        self.revealed = False        self.is_mine = False        self.is_flagged = False        self.position = (x,y)        Context.mine_tiles.add(self.position)    def scan_context(self, tile_grid):        pass    def on_click(self, tile_grid):        if self.revealed or self.is_flagged:            return False        self.revealed = True        Log.add(message=f"Mine tile ({self.x}, {self.y}) has been revealed", level="DEBUG")        return Trueclass TileGrid:    DIRECTIONS = [            (-1,-1), (0,-1), (1,-1),            (-1, 0),         (1, 0),            (-1, 1), (0, 1), (1, 1)                  ]    def __init__(self, num_mines, width=None, height=None):        self.width = width if width is not None else Context.grid_width        self.height = height if height is not None else Context.grid_height        self.grid = [[None for _ in range(self.width)] for _ in range(self.height)]        self.revealed_symbol="R"        self.hidden_symbol="0"        self.mine_symbol="M"        self.is_flagged = "flag"        self._place_mines(num_mines)        self._fill_empty_tiles()        self._scan_all_tiles()    def _place_mines(self, num_mines):        positions = [(x, y) for y in range(self.height) for x in range(self.width)]        random.shuffle(positions)        for i in range(num_mines):            x, y = positions[i]            self.grid[y][x] = MineTile(x, y)    def _fill_empty_tiles(self):        for y in range(self.height):            for x in range(self.width):                if self.grid[y][x] is None:                    self.grid[y][x] = EmptyTile(x, y)    def _scan_all_tiles(self):        for row in self.grid:            for tile in row:                tile.scan_context(self)    def get_neighbors(self, x, y):        neighbors = []        for dx, dy in self.DIRECTIONS:            nx, ny = x + dx, y + dy            if 0 <= nx < self.width and 0 <= ny < self.height:                neighbors.append(self.grid[ny][nx])        return neighbors    def render_grid(self) -> list[list[str]]:        visual_grid = []        for row in self.grid:            visual_row = []            for tile in row:                if isinstance(tile, EmptyTile):                    if not tile.revealed and not tile.is_flagged:                        visual_row.append(self.hidden_symbol)                    elif tile.adjacent_mines == 0:                        visual_row.append(self.revealed_symbol)                    elif tile.is_flagged:                        visual_row.append(self.is_flagged)                    else:                        visual_row.append(str(tile.adjacent_mines))                elif isinstance(tile, MineTile):                    if tile.revealed:                        visual_row.append(self.mine_symbol)                    elif tile.is_flagged:                        visual_row.append(self.is_flagged)                    else:                        visual_row.append(self.hidden_symbol)                else:                    visual_row.append("?")            visual_grid.append(visual_row)        return visual_grid    def render_cheat_grid(self) -> list[list[str]]:        visual_grid = []        for row in self.grid:            visual_row = []            for tile in row:                if tile.is_flagged:                    visual_row.append(" P ")                elif isinstance(tile, EmptyTile):                    if tile.revealed:                        if tile.adjacent_mines == 0:                            visual_row.append(" . ")                        else:                            visual_row.append(f" {tile.adjacent_mines} ")                    else:                        visual_row.append(" : ")                elif isinstance(tile, MineTile):                    visual_row.append(" M ")                else:                    visual_row.append(" ? ")            visual_grid.append(visual_row)        return visual_gridclass GridInterface:    @staticmethod    def get_current_tile():        x, y = Context.position_2D        y -= 1        return Context.grid.grid[y][x]    @staticmethod    def click():        tile = GridInterface.get_current_tile()        result = tile.on_click(Context.grid)        Context.raw_grid = Context.grid.render_grid()        return result    @staticmethod    def flag():        tile = GridInterface.get_current_tile()        tile.is_flagged = not tile.is_flagged        try:            Context.mine_tiles.remove(tile.position)        except KeyError:            pass        Context.raw_grid = Context.grid.render_grid()